---
title: "Time Series Project"
date: 2018-02-18
author: "Paul Forst, Tammy Hang, Rachel Kopecky, Jack Letcher, Ian O'Connor"
output:
  html_document:
    toc: yes
    toc_depth: 4
    toc_float: yes
  html_notebook:
    fig_caption: yes
    highlight: textmate
    theme: cosmo
    toc: yes
    toc_depth: 4
    toc_float: yes
---

```{r global_options, include = FALSE}

knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

```

```{r include=FALSE}
#   Load Required Packages and Files  
#   Check that necessary packages are installed

packages <- c("tidyverse", "lubridate", "forecast", "tibbletime", "ggplot2", "ggthemes", "stringr", "gridExtra", "fpp", "astsa")

new.packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

#   Load Neccessary Packages
sapply(packages, library, character.only = TRUE)
```


# Problem Definition

* Help forecast staffing needs based on the growth and seasonal trends of the client 
* Understand the potential demands that client sales/clearances have on traffic 


*Approach* 

* Analyze the inbound and outbound loads at the main warehouse 
* Mainly look at a monthly view but also potentially dive down to days of the week to better understand staffing at micro level 
* While inbound and outbound are highly(?) correlated, there are some differences that could potentially be used to save on resource costs 

 
*Goals* 

* Allow better management and staffing practices to increase productivity and reduce costs 
* Increase the bottom line 


# Exploration

```{r}
inbound <- read.csv("Inbound Data.csv")
outbound <- read.csv("Outbound Data.csv")

#Convert Date to proper date class
inbound$Date <- mdy(inbound$Date)
outbound$Date <- mdy(outbound$Date)

#correction for comma in a Dollars field
inbound$Dollars <- str_replace(inbound$Dollars, ',', "")
outbound$Dollars <- str_replace(outbound$Dollars, ',', "")

#Convert Dollars and Wage to numeric
inbound$Dollars <- as.numeric(sub('\\$','',as.character(inbound$Dollars))) 
outbound$Dollars <- as.numeric(sub('\\$','',as.character(outbound$Dollars)))
inbound$Wage <- as.numeric(sub('\\$','',as.character(inbound$Wage))) 
outbound$Dollars <- as.numeric(sub('\\$','',as.character(outbound$Wage)))

#Order by Date
inbound <- inbound[order(inbound$Date), ]
outbound <- outbound[order(outbound$Date), ]

all <- rbind(inbound, outbound)

#Use tibble time to convert the data frames to time series
inbound <- as_tbl_time(inbound, Date) %>% 
  group_by(Report.Location)
outbound <- as_tbl_time(outbound, Date) %>% 
  group_by(Report.Location)
all <- as_tbl_time(all, Date) %>% 
  group_by(Report.Location)

#Aggregate to location and day level to first plot
# inbound_summary_monthly <- inbound %>% 
#   dplyr::arrange(Report.Location, Date) %>% 
#   dplyr::mutate(Date = collapse_index(Date, "monthly")) %>% 
#   dplyr::group_by(Report.Location, Date, add = TRUE) %>% 
#   dplyr::summarise(ttl_hrs = sum(Hours), 
#                    ttl_pay = sum(Dollars), 
#                    median_wage = median(Wage))

summary_monthly <- all %>% 
  dplyr::arrange(Report.Location, Date) %>% 
  dplyr::mutate(Date = collapse_index(Date, "monthly")) %>% 
  dplyr::group_by(Dept, Report.Location, Date, add = TRUE) %>% 
  dplyr::mutate(num = length(unique(Badge))) %>% 
  dplyr::summarise(ttl_hrs = sum(Hours), 
                   ttl_pay = sum(Dollars), 
                   median_wage = median(as.numeric(Wage)),
                   num = sum(num))



summary_quarterly <- all %>% 
  dplyr::arrange(Report.Location, Date) %>% 
  dplyr::mutate(Date = collapse_index(Date, "quarterly")) %>% 
  dplyr::group_by(Dept, Report.Location, Date, add = TRUE) %>% 
  dplyr::summarise(ttl_hrs = sum(Hours), 
                   ttl_pay = sum(Dollars), 
                   median_wage = median(as.numeric(Wage)))


# inbound_summary_quarterly <- inbound %>% 
#   dplyr::arrange(Report.Location, Date) %>% 
#   dplyr::mutate(Date = collapse_index(Date, "quarterly")) %>% 
#   dplyr::group_by(Report.Location, Date, add = TRUE) %>% 
#   dplyr::summarise(ttl_hrs = sum(Hours), 
#                    ttl_pay = sum(Dollars), 
#                    median_wage = median(Wage))

Sys.setenv(TZ = 'America/Louisville')

all$Date <- as.POSIXct(all$Date, tz = 'America/Louisville')

# inbound_summary_weekly <- inbound %>% 
#   dplyr::arrange(Report.Location, Date) %>% 
#   dplyr::mutate(Date = collapse_index(Date, "weekly")) %>% 
#   dplyr::group_by(Report.Location, Date, add = TRUE) %>% 
#   dplyr::summarise(ttl_hrs = sum(Hours), 
#                    ttl_pay = sum(Dollars), 
#                    median_wage = median(Wage))

summary_weekly <- all %>% 
  dplyr::arrange(Report.Location, Date) %>% 
  dplyr::mutate(Date = collapse_index(Date, "weekly")) %>% 
  dplyr::group_by(Dept, Report.Location, Date, add = TRUE) %>% 
  dplyr::mutate(num = length(unique(Badge))) %>% 
  dplyr::summarise(ttl_hrs = sum(Hours), 
                   ttl_pay = sum(Dollars), 
                   median_wage = median(as.numeric(Wage)),
                   num = sum(num))



```


```{r}

p1 <- summary_quarterly %>% 
  ggplot(aes(Date, 
             ttl_pay)) +
  geom_line(aes(color = Report.Location, linetype = Dept)) +
  scale_y_continuous(labels = scales::dollar) +
  theme_tufte() +
  ggtitle("Total Pay by Quarter") +
  ylab("Total Pay") +
  theme(axis.title.x = element_blank()) 

p2 <- summary_monthly %>% 
  ggplot(aes(Date, 
             ttl_pay)) +
  geom_line(aes(color = Report.Location, linetype = Dept)) +
  scale_y_continuous(labels = scales::dollar) +
  theme_tufte() +
  ggtitle("Total Pay by Month") +
  ylab("Total Pay") +
  theme(axis.title.x = element_blank(), legend.position = "none")

p3 <- summary_weekly %>% 
  ggplot(aes(Date, 
             ttl_pay)) +
  geom_line(aes(color = Report.Location, linetype = Dept)) +
  scale_y_continuous(labels = scales::dollar) +
  theme_tufte() +
  ggtitle("Total Pay by Week") +
  ylab("Total Pay") +
  theme(axis.title.x = element_blank(), legend.position = "none")

grid.arrange(p1, p2, p3, nrow = 3)

```

```{r}

p4 <- summary_quarterly %>% 
  ggplot(aes(Date, 
             ttl_hrs)) +
  geom_line(aes(color = Report.Location, linetype = Dept)) +
  scale_y_continuous() +
  theme_tufte() +
  ggtitle("Total Hours by Quarter") +
  ylab("Total Hours") +
  theme(axis.title.x = element_blank())

p5 <- summary_monthly %>% 
  ggplot(aes(Date, 
             ttl_hrs)) +
  geom_line(aes(color = Report.Location, linetype = Dept)) +
  scale_y_continuous() +
  theme_tufte() +
  ggtitle("Total Hours by Month") +
  ylab("Total Hours") +
  theme(axis.title.x = element_blank(), legend.position = "none")


p6 <- summary_weekly %>% 
  ggplot(aes(Date, 
             ttl_hrs)) +
  geom_line(aes(color = Report.Location, linetype = Dept)) +
  scale_y_continuous() +
  theme_tufte() +
  ggtitle("Total Hours by Week") +
  ylab("Total Hours") +
  theme(axis.title.x = element_blank(), legend.position = "none")

grid.arrange(p4, p5, p6, nrow = 3)

```

It appears that there may be seasonality and trend in both the Inbound and Outbound data. Also, the random fluctuations in the data do not appear to be constant over time, so we may need to use a multiplicative decomposition model to describe this series.

## Decomposition

### Inbound

```{r fig.width = 10}

#Need to decompose and plot
#Start with monthly inbound data at the LOU location
inbound_summary_monthly_hrs_ts <- summary_monthly %>%
  filter(Report.Location == "LOU" & Dept == "Inbound")  %>% 
  ungroup() %>% 
  select(ttl_hrs)

inbound_summary_monthly_pay_ts <- summary_monthly %>%
  filter(Report.Location == "LOU" & Dept == "Inbound")  %>% 
  ungroup() %>% 
  select(ttl_pay)

# convert data frame to time series object
inbound_summary_monthly_hrs_ts <- ts(data = inbound_summary_monthly_hrs_ts, start = c(2015,1), frequency = 12)
inbound_summary_monthly_pay_ts <- ts(data = inbound_summary_monthly_pay_ts, start = c(2015,1), frequency = 12)

# str(inbound_summary_ts)

d1<- autoplot(decompose(inbound_summary_monthly_hrs_ts), main = "Total Hours per Month (Additive Decomp)")
#plot(decompose(inbound_summary_monthly_hrs_ts, type = "multiplicative"))

d2 <- autoplot(decompose(inbound_summary_monthly_pay_ts), main = "Total Pay per Month (Additive Decomp)")
#plot(decompose(inbound_summary_monthly_pay_ts, type = "multiplicative"))


grid.arrange(d1,d2, ncol = 2)

```

After looking at the decomposition of the monthly inbound series for both hours and pay, it appears that both of these can be described by an additive model, as the variation in the random component appears to be roughly constant over time.

```{r fig.width = 10}

#Need to decompose and plot
#Start with monthly inbound data at the LOU location
inbound_summary_weekly_hrs_ts <- summary_weekly %>%
  filter(Report.Location == "LOU" & Dept == "Inbound")  %>% 
  ungroup() %>% 
  select(ttl_hrs)

inbound_summary_weekly_pay_ts <- summary_weekly %>%
  filter(Report.Location == "LOU" & Dept == "Inbound")  %>% 
  ungroup() %>% 
  select(ttl_pay)

# convert data frame to time series object
inbound_summary_weekly_hrs_ts <- ts(data = inbound_summary_weekly_hrs_ts, start = c(2015,1), frequency = 52)
inbound_summary_weekly_pay_ts <- ts(data = inbound_summary_weekly_pay_ts, start = c(2015,1), frequency = 52)

# str(inbound_summary_ts)
d3 <- autoplot(decompose(inbound_summary_weekly_hrs_ts), main = "Total Hours per Week (Additive Decomp)")
#plot(decompose(inbound_summary_weekly_hrs_ts, type = "multiplicative"))

d4 <- autoplot(decompose(inbound_summary_weekly_pay_ts), main = "Total Pay per Week (Additive Decomp)")
#plot(decompose(inbound_summary_weekly_pay_ts, type = "multiplicative"))

grid.arrange(d3, d4, ncol = 2)
```

Again, the decomposition of the inbound weekly series for both hours and pay appear to have roughly constant variation in the random component, and thus an additive decomposition model is sufficient.

### Outbound
```{r fig.width = 12, fig.height = 9}

#Need to decompose and plot
#Start with monthly inbound data at the LOU location
outbound_summary_monthly_hrs_ts <- summary_monthly %>%
  filter(Report.Location == "LOU" & Dept == "Outbound")  %>% 
  ungroup() %>% 
  select(ttl_hrs)

outbound_summary_monthly_pay_ts <- summary_monthly %>%
  filter(Report.Location == "LOU" & Dept == "Outbound")  %>% 
  ungroup() %>% 
  select(ttl_pay)

# convert data frame to time series object
outbound_summary_monthly_hrs_ts <- ts(data = outbound_summary_monthly_hrs_ts, start = c(2015,1), frequency = 12)
outbound_summary_monthly_pay_ts <- ts(data = outbound_summary_monthly_pay_ts, start = c(2015,1), frequency = 12)

layout(matrix(c(1,1,2,2), 2, 2, byrow = TRUE))

# str(inbound_summary_ts)
d5 <- autoplot(decompose(outbound_summary_monthly_hrs_ts), main = "Total Hours per Month (Additive Decomp)")

d6 <- autoplot(decompose(outbound_summary_monthly_hrs_ts, type = "multiplicative"), main = "Total Hours per Month (Multiplicative Decomp)")
outbound_monthly_decomp_hrs <- decompose(outbound_summary_monthly_hrs_ts, type = "multiplicative")

d7 <- autoplot(decompose(outbound_summary_monthly_pay_ts), main = "Total Pay per Month (Additive Decomp)")

d8 <- autoplot(decompose(outbound_summary_monthly_pay_ts, type = "multiplicative"), main = "Total Pay per Month (Multiplicative Decomp)")
outbound_monthly_decomp_pay <- decompose(outbound_summary_monthly_pay_ts, type = "multiplicative")

grid.arrange(d5, d6, d7, d8, nrow = 2, ncol = 2)
```

The variation in the random component of the monthly outbound series does not appear to be constant, so we will need to use a multiplicative decomposition for this series.

```{r fig.width = 12, fig.height = 9}

#Need to decompose and plot
#Start with monthly inbound data at the LOU location
outbound_summary_weekly_hrs_ts <- summary_weekly %>%
  filter(Report.Location == "LOU" & Dept == "Outbound")  %>% 
  ungroup() %>% 
  select(ttl_hrs)

outbound_summary_weekly_pay_ts <- summary_weekly %>%
  filter(Report.Location == "LOU" & Dept == "Outbound")  %>% 
  ungroup() %>% 
  select(ttl_pay)

# convert data frame to time series object
outbound_summary_weekly_hrs_ts <- ts(data = outbound_summary_weekly_hrs_ts, start = c(2015,1), frequency = 52)
outbound_summary_weekly_pay_ts <- ts(data = outbound_summary_weekly_pay_ts, start = c(2015,1), frequency = 52)

# str(inbound_summary_ts)
d9 <- autoplot(decompose(outbound_summary_weekly_hrs_ts), main = "Total Hours per Week (Additive Decomp)")

d10 <- autoplot(decompose(outbound_summary_weekly_hrs_ts, type = "multiplicative"), main = "Total Hours per Week (Multiplicative Decomp)")
outbound_weekly_decomp_hrs <- decompose(outbound_summary_weekly_hrs_ts, type = "multiplicative")

d11 <- autoplot(decompose(outbound_summary_weekly_pay_ts), main = "Total Pay per Week (Additive Decomp)")

d12 <- autoplot(decompose(outbound_summary_weekly_pay_ts, type = "multiplicative"), main = "Total Pay per Week (Multiplicative Decomp)")
outbound_weekly_decomp_pay <- decompose(outbound_summary_weekly_pay_ts, type = "multiplicative")

grid.arrange(d9,d10,d11,d12, nrow = 2, ncol = 2)
```

Again, the variation in the random component of the weekly outbound series does not appear to be constant, so we will need to use a multiplicative decomposition for this series.

#Forecasting

## Mean

```{r fig.width = 12, fig.height = 9}

m1 <- autoplot(meanf(inbound_summary_monthly_hrs_ts, h = 24), main = "Inbound, Total Hours per Month", ylab = "Total Hours")

m2 <- autoplot(meanf(inbound_summary_monthly_pay_ts, h = 24), main = "Inbound, Total Pay per Month", ylab = "Total Pay")

m3 <- autoplot(meanf(outbound_summary_monthly_hrs_ts, h = 24), main = "Outbound, Total Hours per Month", ylab = "Total Hours")

m4 <- autoplot(meanf(outbound_summary_monthly_pay_ts, h = 24), main = "Outbound, Total Pay per Month", ylab = "Total Pay")

grid.arrange(m1, m2, m3, m4, nrow = 2, ncol = 2)
```

## Random Walk 

```{r}

r1 <- autoplot(rwf(inbound_summary_monthly_hrs_ts, h = 24, drift = F), main = "Random Walk, Monthly Hours", ylab = "Total Hours") 
r2 <- autoplot(rwf(inbound_summary_monthly_hrs_ts, h = 24, drift = T), main = "Random Walk with Drift, Monthly Hours", ylab = "Total Hours")

r3 <- autoplot(rwf(inbound_summary_monthly_pay_ts, h = 24, drift = F), main = "Random Walk, Monthly Pay", ylab = "Total Pay")
r4 <- autoplot(rwf(inbound_summary_monthly_pay_ts, h = 24, drift = T), main = "Random Walk with Drift, Monthly Pay", ylab = "Total Pay")

r5 <- autoplot(rwf(outbound_summary_monthly_hrs_ts, h = 24, drift = F), main = "Random Walk, Monthly Hours", ylab = "Total Hours")
r6 <- autoplot(rwf(outbound_summary_monthly_hrs_ts, h = 24, drift = T), main = "Random Walk with Drift, Monthly Hours", ylab = "Total Hours")

r7 <- autoplot(rwf(outbound_summary_monthly_pay_ts, h = 24, drift = F), main = "Random Walk, Monthly Pay", ylab = "Total Pay")
r8 <- autoplot(rwf(outbound_summary_monthly_pay_ts, h = 24, drift = T), main = "Random Walk with Drift, Monthly Pay", ylab = "Total Pay")

```

### Inbound

```{r fig.width = 12, fig.height = 9}
grid.arrange(r1, r2, r3, r4, nrow = 2, ncol = 2)
```

### Outbound

```{r fig.width = 12, fig.height = 9}
grid.arrange(r5, r6, r7, r8, nrow = 2, ncol = 2)
```

## Seasonal Naive

### Inbound
```{r fig.width=12, fig.height=9}
s1 <- autoplot(snaive(inbound_summary_monthly_hrs_ts, h = 24), main = "Inbound, Total Hours per Month", ylab = "Total Hours")

s2 <- autoplot(snaive(inbound_summary_monthly_pay_ts, h = 24), main = "Inbound, Total Pay per Month", ylab = "Total Pay")

grid.arrange(s1, s2, nrow = 2)
```

### Outbound
```{r}
s3 <- autoplot(snaive(outbound_summary_monthly_hrs_ts, h = 24), main = "Outbound, Total Hours per Month", ylab = "Total Hours")

s4 <- autoplot(snaive(outbound_summary_monthly_pay_ts, h = 24), main = "Outbound, Total Pay per Month", ylab = "Total Pay")

grid.arrange(s3, s4, nrow = 2)
```

## Exponential Smoothing

### Holt-Winters
#### Inbound

Based on the decompositions from above, for the inbound series, we will need use the Holt-Winters seasonal *additive* method.

```{r}
# Hours
inbound_monthly_hrs_HW <- hw(inbound_summary_monthly_hrs_ts, seasonal = "additive")
hw1 <- autoplot(inbound_monthly_hrs_HW, main = "Holt-Winters Forecast, Inbound Monthly Hours", ylab = "Total Hours")

inbound_weekly_hrs_HoltWinters <- HoltWinters(inbound_summary_weekly_hrs_ts)
hw3 <- autoplot(forecast(inbound_weekly_hrs_HoltWinters), main = "Holt-Winters Forecast, Inbound Weekly Hours", ylab = "Total Hours")

grid.arrange(hw1, hw3, nrow = 2)
```

Based on the Holt-Winters forecast for our monthly series, both our inbound hours and pay are expected to continue to increase heavily through 2018.

```{r}

inbound_monthly_pay_HoltWinters <- hw(inbound_summary_monthly_pay_ts, seasonal = "additive")
hw2 <- autoplot(inbound_monthly_pay_HoltWinters, main = "Holt-Winters Forecast, Inbound Monthly Pay", ylab = "Total Pay")

# Pay
inbound_weekly_pay_HoltWinters <- HoltWinters(inbound_summary_weekly_pay_ts)
hw4 <- autoplot(forecast(inbound_weekly_pay_HoltWinters), main = "Holt-Winters Forecast, Inbound Weekly Pay", ylab = "Total Pay")

grid.arrange(hw2, hw4, nrow = 2)
```

Our Holt-Winters forecasts for the weekly series appear to be lower than those for the monthly series, and they do not increase as dramatically moving into 2018. We will need to further analyze both the series and the forecasts to determine which is closer to what we should expect moving forward.

#### Outbound

For the outbound series, we will need use the Holt-Winters seasonal *multiplicative* method.

```{r}
# Monthly
# Hours

outbound_monthly_hrs_HW <- hw(outbound_summary_monthly_hrs_ts, seasonal = "multiplicative")
hw5 <- autoplot(outbound_monthly_hrs_HW, main = "Holt-Winters Forecast, Outbound Monthly Hours", ylab = "Total Hours")

# Pay
outbound_monthly_pay_HoltWinters <- hw(outbound_summary_monthly_pay_ts, seasonal = "multiplicative")
hw6 <- autoplot(outbound_monthly_pay_HoltWinters, main = "Holt-Winters Forecast, Outbound Monthly Pay", ylab = "Total Pay")

grid.arrange(hw5, hw6, nrow = 2)
```

The `hw` function cannot handle a series with frequency greater than 24 (in a two year period), so we cannot forecast the weekly series using the multiplicative method.

<!-- Next we should test if our models are stationary, whether or not autocorrelation exists. If they are non-stationary, then we could possibly improve them using a different technique. -->

<!-- ```{r} -->

<!-- acf(inbound_monthly_hrs_HoltWinters_Forecast$residuals[13:36]) -->
<!-- Box.test(inbound_monthly_hrs_HoltWinters_Forecast$residuals[13:36]) -->
<!-- ``` -->
<!-- ```{r} -->
<!-- acf(inbound_monthly_pay_HoltWinters_Forecast$residuals[13:36]) -->
<!-- Box.test(inbound_monthly_pay_HoltWinters_Forecast$residuals[13:36]) -->
<!-- ``` -->
<!-- ```{r} -->
<!-- acf(inbound_weekly_hrs_HoltWinters_Forecast$residuals[53:156]) -->
<!-- Box.test(inbound_weekly_hrs_HoltWinters_Forecast$residuals[53:156]) -->
<!-- ``` -->
<!-- ```{r} -->
<!-- acf(inbound_weekly_pay_HoltWinters_Forecast$residuals[53:156]) -->
<!-- Box.test(inbound_weekly_pay_HoltWinters_Forecast$residuals[53:156]) -->
<!-- ``` -->

<!-- All of our Holt-Winters models for the inbound series appear to be stationary. -->

## ARIMA

We can sometimes create better forecasts by utilizing ARIMA models. 

#### Inbound

```{r evaluate = FALSE, include = FALSE}
adf.test(inbound_summary_monthly_hrs_ts)
adf.test(inbound_summary_monthly_pay_ts)
adf.test(inbound_summary_weekly_hrs_ts)
adf.test(inbound_summary_weekly_pay_ts)
```

From the Dickey-Fuller test, we can confirm that the weekly pay series is stationary, while the weekly hours and both monthly are not. We apply some differencing below:

```{r }
#Montly Hours
df1 <- autoplot(inbound_summary_monthly_hrs_ts, main = "Inbound Hours per Month", ylab = "Total Hours")
inbound_summary_monthly_hrs_ts_Diff <- diff(inbound_summary_monthly_hrs_ts)
df2 <- autoplot(inbound_summary_monthly_hrs_ts_Diff, main = "Inbound Hours per Month, Difference = 1", ylab = "Total Hours")

inbound_summary_monthly_hrs_ts2 <- diff(inbound_summary_monthly_hrs_ts, differences = 2)
df3 <- autoplot(inbound_summary_monthly_hrs_ts2, main = "Inbound Hours per Month, Difference = 2", ylab = "Total Hours")

grid.arrange(df1, df2, df3, nrow = 3)
```

A difference of 2 appears to make the monthly hours series stationary, and we find that this is the case for the monthly pay and weekly hours series as well. We can then begin to build our ARIMA models. We will use the `auto.arima` function that will choose the best ARIMA model to fit to each series.

```{r}
inbound_summary_monthly_hrs_ts_ARIMA <- auto.arima(inbound_summary_monthly_hrs_ts)
inbound_summary_monthly_hrs_ts_forecast <- forecast(inbound_summary_monthly_hrs_ts_ARIMA)
a1 <- autoplot(inbound_summary_monthly_hrs_ts_forecast, main = "ARIMA Forecast, Inbound Monthly Hours", ylab = "Total Hours")

inbound_summary_weekly_hrs_ts_ARIMA <- auto.arima(inbound_summary_weekly_hrs_ts)
inbound_summary_weekly_hrs_ts_forecast <- forecast(inbound_summary_weekly_hrs_ts_ARIMA)
a3 <- autoplot(inbound_summary_weekly_hrs_ts_forecast, main = "ARIMA Forecast, Inbound Weekly Hours", ylab = "Total Hours")


grid.arrange(a1, a3, nrow = 2)

```

```{r}
inbound_summary_monthly_pay_ts_ARIMA <- auto.arima(inbound_summary_monthly_pay_ts)
inbound_summary_monthly_pay_ts_forecast <- forecast(inbound_summary_monthly_pay_ts_ARIMA)
a2 <- autoplot(inbound_summary_monthly_pay_ts_forecast, main = "ARIMA Forecast, Inbound Monthly Pay", ylab = "Total Pay")

inbound_summary_weekly_pay_ts_ARIMA <- auto.arima(inbound_summary_weekly_pay_ts)
inbound_summary_weekly_ts_forecast <- forecast(inbound_summary_weekly_pay_ts_ARIMA)
a4 <- autoplot(inbound_summary_weekly_ts_forecast, main = "ARIMA Forecast, Inbound Weekly Pay", ylab = "Total Pay")

grid.arrange(a2, a4, nrow = 2)

```

#### Outbound

Next we will use ARIMA to forecast our outbound series.

```{r evaluate = FALSE, include = FALSE}

acf(outbound_summary_monthly_hrs_ts)
acf(outbound_summary_monthly_pay_ts)
acf(outbound_summary_weekly_hrs_ts)
acf(outbound_summary_weekly_pay_ts)

```

```{r evaluate = FALSE, include = FALSE}
 adf.test(outbound_summary_monthly_hrs_ts)
 adf.test(outbound_summary_monthly_pay_ts)
 adf.test(outbound_summary_weekly_hrs_ts)
 adf.test(outbound_summary_weekly_pay_ts)
```

From the Dickey-Fuller test, we can confirm that the weekly series are stationary, while the monthly are not. We again find that both the monthly hours and pay series can achieve stationarity after two differences.

```{r include = FALSE}

outbound_monthly_hrs_diff1 <- diff(outbound_summary_monthly_hrs_ts, differences = 1)
adf.test(outbound_monthly_hrs_diff1)

outbound_monthly_hrs_diff2 <- diff(outbound_summary_monthly_hrs_ts, differences = 2)
adf.test(outbound_monthly_hrs_diff2)

```

<!-- The monthly hours series achieves stationarity after two differences. We can see below that this is the same for the monthly pay series as well. -->

```{r include = FALSE}

outbound_monthly_pay_diff1 <- diff(outbound_summary_monthly_pay_ts, differences = 1)
adf.test(outbound_monthly_pay_diff1)

outbound_monthly_pay_diff2 <- diff(outbound_summary_monthly_pay_ts, differences = 2)
adf.test(outbound_monthly_pay_diff2)

```

Again we will use `auto.arima` to fit the models.

```{r}
# Outbound ARIMA Models
monthly_hours <- auto.arima(outbound_summary_monthly_hrs_ts)
a5 <- autoplot(forecast(monthly_hours), main = "ARIMA Forecast, Outbound Monthly Hours", ylab = "Total Hours")

weekly_hours <- auto.arima(outbound_summary_weekly_hrs_ts)
a7 <- autoplot(forecast(weekly_hours), main = "ARIMA Forecast, Outbound Weekly Hours", ylab = "Total Hours")

grid.arrange(a5, a7, nrow = 2)
```

```{r}
monthly_pay <- auto.arima(outbound_summary_monthly_pay_ts)
a6 <- autoplot(forecast(monthly_pay), main = "ARIMA Forecast, Outbound Monthly Pay", ylab = "Total Pay")

weekly_pay <- auto.arima(outbound_summary_weekly_pay_ts)
a8 <- autoplot(forecast(weekly_pay), main = "ARIMA Forecast, Outbound Weekly Pay", ylab = "Total Pay")

grid.arrange(a6, a8, nrow = 2)
```

# Conclusion
