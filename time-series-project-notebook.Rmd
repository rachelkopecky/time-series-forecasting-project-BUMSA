---
title: "Time Series Project"
date: 2018-02-18
author: "Paul Forst, Tammy Hang, Rachel Kopecky, Jack Letcher, Ian O'Connor"
output:
  html_document:
    toc: yes
    toc_depth: 4
    toc_float: yes
  html_notebook:
    fig_caption: yes
    highlight: textmate
    theme: cosmo
    toc: yes
    toc_depth: 4
    toc_float: yes
---

```{r global_options, include = FALSE}

knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

```

```{r include=FALSE}
#   Load Required Packages and Files  
#   Check that necessary packages are installed

packages <- c("tidyverse", "lubridate", "forecast", "tibbletime", "ggplot2", "ggthemes", "stringr", "gridExtra", "fpp", "astsa")

new.packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

#   Load Neccessary Packages
sapply(packages, library, character.only = TRUE)
```


# Problem Definition

* Help forecast staffing needs based on the growth and seasonal trends of the client 
* Understand the potential demands that client sales/clearances have on traffic 


*Approach* 

* Analyze the inbound and outbound loads at the main warehouse 
* Mainly look at a monthly view but also potentially dive down to days of the week to better understand staffing at micro level 
* While inbound and outbound are highly(?) correlated, there are some differences that could potentially be used to save on resource costs 

 
*Goals* 

* Allow better management and staffing practices to increase productivity and reduce costs 
* Increase the bottom line 


# Exploration

```{r}
inbound <- read.csv("Inbound Data.csv")
outbound <- read.csv("Outbound Data.csv")

#Convert Date to proper date class
inbound$Date <- mdy(inbound$Date)
outbound$Date <- mdy(outbound$Date)

#correction for comma in a Dollars field
inbound$Dollars <- str_replace(inbound$Dollars, ',', "")
outbound$Dollars <- str_replace(outbound$Dollars, ',', "")

#Convert Dollars and Wage to numeric
inbound$Dollars <- as.numeric(sub('\\$','',as.character(inbound$Dollars))) 
outbound$Dollars <- as.numeric(sub('\\$','',as.character(outbound$Dollars)))
inbound$Wage <- as.numeric(sub('\\$','',as.character(inbound$Wage))) 
outbound$Dollars <- as.numeric(sub('\\$','',as.character(outbound$Wage)))

#Order by Date
inbound <- inbound[order(inbound$Date), ]
outbound <- outbound[order(outbound$Date), ]

all <- rbind(inbound, outbound)

#Use tibble time to convert the data frames to time series
inbound <- as_tbl_time(inbound, Date) %>% 
  group_by(Report.Location)
outbound <- as_tbl_time(outbound, Date) %>% 
  group_by(Report.Location)
all <- as_tbl_time(all, Date) %>% 
  group_by(Report.Location)

#Aggregate to location and day level to first plot
# inbound_summary_monthly <- inbound %>% 
#   dplyr::arrange(Report.Location, Date) %>% 
#   dplyr::mutate(Date = collapse_index(Date, "monthly")) %>% 
#   dplyr::group_by(Report.Location, Date, add = TRUE) %>% 
#   dplyr::summarise(ttl_hrs = sum(Hours), 
#                    ttl_pay = sum(Dollars), 
#                    median_wage = median(Wage))

summary_monthly <- all %>% 
  dplyr::arrange(Report.Location, Date) %>% 
  dplyr::mutate(Date = collapse_index(Date, "monthly")) %>% 
  dplyr::group_by(Dept, Report.Location, Date, add = TRUE) %>% 
  dplyr::mutate(num = length(unique(Badge))) %>% 
  dplyr::summarise(ttl_hrs = sum(Hours), 
                   ttl_pay = sum(Dollars), 
                   median_wage = median(as.numeric(Wage)),
                   num = sum(num))



summary_quarterly <- all %>% 
  dplyr::arrange(Report.Location, Date) %>% 
  dplyr::mutate(Date = collapse_index(Date, "quarterly")) %>% 
  dplyr::group_by(Dept, Report.Location, Date, add = TRUE) %>% 
  dplyr::summarise(ttl_hrs = sum(Hours), 
                   ttl_pay = sum(Dollars), 
                   median_wage = median(as.numeric(Wage)))


# inbound_summary_quarterly <- inbound %>% 
#   dplyr::arrange(Report.Location, Date) %>% 
#   dplyr::mutate(Date = collapse_index(Date, "quarterly")) %>% 
#   dplyr::group_by(Report.Location, Date, add = TRUE) %>% 
#   dplyr::summarise(ttl_hrs = sum(Hours), 
#                    ttl_pay = sum(Dollars), 
#                    median_wage = median(Wage))

Sys.setenv(TZ = 'America/Louisville')

all$Date <- as.POSIXct(all$Date, tz = 'America/Louisville')

# inbound_summary_weekly <- inbound %>% 
#   dplyr::arrange(Report.Location, Date) %>% 
#   dplyr::mutate(Date = collapse_index(Date, "weekly")) %>% 
#   dplyr::group_by(Report.Location, Date, add = TRUE) %>% 
#   dplyr::summarise(ttl_hrs = sum(Hours), 
#                    ttl_pay = sum(Dollars), 
#                    median_wage = median(Wage))

summary_weekly <- all %>% 
  dplyr::arrange(Report.Location, Date) %>% 
  dplyr::mutate(Date = collapse_index(Date, "weekly")) %>% 
  dplyr::group_by(Dept, Report.Location, Date, add = TRUE) %>% 
  dplyr::mutate(num = length(unique(Badge))) %>% 
  dplyr::summarise(ttl_hrs = sum(Hours), 
                   ttl_pay = sum(Dollars), 
                   median_wage = median(as.numeric(Wage)),
                   num = sum(num))



```


```{r}

p1 <- summary_quarterly %>% 
  ggplot(aes(Date, 
             ttl_pay)) +
  geom_line(aes(color = Report.Location, linetype = Dept)) +
  scale_y_continuous(labels = scales::dollar) +
  theme_tufte() +
  ggtitle("Total Pay by Quarter") +
  ylab("Total Pay") +
  theme(axis.title.x = element_blank()) 

p2 <- summary_monthly %>% 
  ggplot(aes(Date, 
             ttl_pay)) +
  geom_line(aes(color = Report.Location, linetype = Dept)) +
  scale_y_continuous(labels = scales::dollar) +
  theme_tufte() +
  ggtitle("Total Pay by Month") +
  ylab("Total Pay") +
  theme(axis.title.x = element_blank(), legend.position = "none")

p3 <- summary_weekly %>% 
  ggplot(aes(Date, 
             ttl_pay)) +
  geom_line(aes(color = Report.Location, linetype = Dept)) +
  scale_y_continuous(labels = scales::dollar) +
  theme_tufte() +
  ggtitle("Total Pay by Week") +
  ylab("Total Pay") +
  theme(axis.title.x = element_blank(), legend.position = "none")

grid.arrange(p1, p2, p3, nrow = 3)

```

```{r}

p4 <- summary_quarterly %>% 
  ggplot(aes(Date, 
             ttl_hrs)) +
  geom_line(aes(color = Report.Location, linetype = Dept)) +
  scale_y_continuous() +
  theme_tufte() +
  ggtitle("Total Hours by Quarter") +
  ylab("Total Hours") +
  theme(axis.title.x = element_blank())

p5 <- summary_monthly %>% 
  ggplot(aes(Date, 
             ttl_hrs)) +
  geom_line(aes(color = Report.Location, linetype = Dept)) +
  scale_y_continuous() +
  theme_tufte() +
  ggtitle("Total Hours by Month") +
  ylab("Total Hours") +
  theme(axis.title.x = element_blank(), legend.position = "none")


p6 <- summary_weekly %>% 
  ggplot(aes(Date, 
             ttl_hrs)) +
  geom_line(aes(color = Report.Location, linetype = Dept)) +
  scale_y_continuous() +
  theme_tufte() +
  ggtitle("Total Hours by Week") +
  ylab("Total Hours") +
  theme(axis.title.x = element_blank(), legend.position = "none")

grid.arrange(p4, p5, p6, nrow = 3)

```

It appears that there may be seasonality and trend in both the Inbound and Outbound data. Also, the random fluctuations in the data do not appear to be constant over time, so we may need to use a multiplicative decomposition model to describe this series.

## Decomposition

### Inbound

#### Monthly

Hours

```{r}

#Need to decompose and plot
#Start with monthly inbound data at the LOU location
inbound_summary_monthly_hrs_ts <- summary_monthly %>%
  filter(Report.Location == "LOU" & Dept == "Inbound")  %>% 
  ungroup() %>% 
  select(ttl_hrs)

inbound_summary_monthly_pay_ts <- summary_monthly %>%
  filter(Report.Location == "LOU" & Dept == "Inbound")  %>% 
  ungroup() %>% 
  select(ttl_pay)

# convert data frame to time series object
inbound_summary_monthly_hrs_ts <- ts(data = inbound_summary_monthly_hrs_ts, start = c(2015,1), frequency = 12)
inbound_summary_monthly_pay_ts <- ts(data = inbound_summary_monthly_pay_ts, start = c(2015,1), frequency = 12)

par(mfrow = c(2,2))

# str(inbound_summary_ts)

plot(decompose(inbound_summary_monthly_hrs_ts))
#plot(decompose(inbound_summary_monthly_hrs_ts, type = "multiplicative"))
inbound_monthly_decomp_hrs <- decompose(inbound_summary_monthly_hrs_ts)
```
Cost
```{r}

plot(decompose(inbound_summary_monthly_pay_ts))
#plot(decompose(inbound_summary_monthly_pay_ts, type = "multiplicative"))
inbound_monthly_decomp_pay <- decompose(inbound_summary_monthly_pay_ts)



```

After looking at the decomposition of the monthly inbound series for both hours and pay, it appears that both of these can be described by an additive model, as the variation in the random component appears to be roughly constant over time.

#### Weekly

Hours
```{r}

#Need to decompose and plot
#Start with monthly inbound data at the LOU location
inbound_summary_weekly_hrs_ts <- summary_weekly %>%
  filter(Report.Location == "LOU" & Dept == "Inbound")  %>% 
  ungroup() %>% 
  select(ttl_hrs)

inbound_summary_weekly_pay_ts <- summary_weekly %>%
  filter(Report.Location == "LOU" & Dept == "Inbound")  %>% 
  ungroup() %>% 
  select(ttl_pay)

# convert data frame to time series object
inbound_summary_weekly_hrs_ts <- ts(data = inbound_summary_weekly_hrs_ts, start = c(2015,1), frequency = 52)
inbound_summary_weekly_pay_ts <- ts(data = inbound_summary_weekly_pay_ts, start = c(2015,1), frequency = 52)

# str(inbound_summary_ts)
plot(decompose(inbound_summary_weekly_hrs_ts))
#plot(decompose(inbound_summary_weekly_hrs_ts, type = "multiplicative"))
inbound_weekly_decomp_hrs <- decompose(inbound_summary_weekly_hrs_ts)
```

Cost
```{r}

plot(decompose(inbound_summary_weekly_pay_ts))
#plot(decompose(inbound_summary_weekly_pay_ts, type = "multiplicative"))
inbound_weekly_decomp_pay <- decompose(inbound_summary_weekly_pay_ts)

```

Again, the decomposition of the inbound weekly series for both hours and pay appear to have roughly constant variation in the random component, and thus an additive decomposition model is sufficient.

### Outbound

#### Monthly

Hours
```{r}

#Need to decompose and plot
#Start with monthly inbound data at the LOU location
outbound_summary_monthly_hrs_ts <- summary_monthly %>%
  filter(Report.Location == "LOU" & Dept == "Outbound")  %>% 
  ungroup() %>% 
  select(ttl_hrs)

outbound_summary_monthly_pay_ts <- summary_monthly %>%
  filter(Report.Location == "LOU" & Dept == "Outbound")  %>% 
  ungroup() %>% 
  select(ttl_pay)

# convert data frame to time series object
outbound_summary_monthly_hrs_ts <- ts(data = outbound_summary_monthly_hrs_ts, start = c(2015,1), frequency = 12)
outbound_summary_monthly_pay_ts <- ts(data = outbound_summary_monthly_pay_ts, start = c(2015,1), frequency = 12)

layout(matrix(c(1,1,2,2), 2, 2, byrow = TRUE))

# str(inbound_summary_ts)
plot(decompose(outbound_summary_monthly_hrs_ts))

plot(decompose(outbound_summary_monthly_hrs_ts, type = "multiplicative"))
outbound_monthly_decomp_hrs <- decompose(outbound_summary_monthly_hrs_ts, type = "multiplicative")
```

Cost
```{r}
plot(decompose(outbound_summary_monthly_pay_ts))
```
```{r}
plot(decompose(outbound_summary_monthly_pay_ts, type = "multiplicative"))
outbound_monthly_decomp_pay <- decompose(outbound_summary_monthly_pay_ts, type = "multiplicative")
```

The variation in the random component of the monthly outbound series does not appear to be constant, so we will need to use a multiplicative decomposition for this series.

#### Weekly

Hours
```{r}

#Need to decompose and plot
#Start with monthly inbound data at the LOU location
outbound_summary_weekly_hrs_ts <- summary_weekly %>%
  filter(Report.Location == "LOU" & Dept == "Outbound")  %>% 
  ungroup() %>% 
  select(ttl_hrs)

outbound_summary_weekly_pay_ts <- summary_weekly %>%
  filter(Report.Location == "LOU" & Dept == "Outbound")  %>% 
  ungroup() %>% 
  select(ttl_pay)

# convert data frame to time series object
outbound_summary_weekly_hrs_ts <- ts(data = outbound_summary_weekly_hrs_ts, start = c(2015,1), frequency = 52)
outbound_summary_weekly_pay_ts <- ts(data = outbound_summary_weekly_pay_ts, start = c(2015,1), frequency = 52)

# str(inbound_summary_ts)
plot(decompose(outbound_summary_weekly_hrs_ts))
```
```{r}
plot(decompose(outbound_summary_weekly_hrs_ts, type = "multiplicative"))
outbound_weekly_decomp_hrs <- decompose(outbound_summary_weekly_hrs_ts, type = "multiplicative")
```

Cost
```{r}
plot(decompose(outbound_summary_weekly_pay_ts))
```
```{r}
plot(decompose(outbound_summary_weekly_pay_ts, type = "multiplicative"))
outbound_weekly_decomp_pay <- decompose(outbound_summary_weekly_pay_ts, type = "multiplicative")
```

Again, the variation in the random component of the weekly outbound series does not appear to be constant, so we will need to use a multiplicative decomposition for this series.

#Forecasting

## Mean

For the outbound series, as they have roughly constant variation and could be explained using an additive model, we can use a mean forecasting method for a short term predictions.

```{r}

OB_monthly_hrs_seas_adj <- outbound_summary_monthly_hrs_ts - outbound_monthly_decomp_hrs$seasonal
OB_monthly_pay_seas_adj <- outbound_summary_monthly_pay_ts - outbound_monthly_decomp_pay$seasonal

OB_monthly_hrs_meanf <- meanf(OB_monthly_hrs_seas_adj[,1], h=24, level=95)
plot(OB_monthly_hrs_meanf)

OB_monthly_pay_meanf <- meanf(OB_monthly_pay_seas_adj[,1], h=24, level=95)
plot(OB_monthly_pay_meanf)
```

## Seasonal Naive

For the outbound series, as they have roughly constant variation and could be explained using an additive model, we can use a seasonal naive forecasting method for a short term predictions.

```{r}

OB_monthly_hrs_seas_adj <- outbound_summary_monthly_hrs_ts - outbound_monthly_decomp_hrs$seasonal
OB_monthly_pay_seas_adj <- outbound_summary_monthly_pay_ts - outbound_monthly_decomp_pay$seasonal

OB_monthly_hrs_snaive <- snaive(OB_monthly_hrs_seas_adj[,1], h=24, level=95)
plot(OB_monthly_hrs_snaive)

OB_monthly_pay_snaive <- snaive(OB_monthly_pay_seas_adj[,1], h=24, level=95)
plot(OB_monthly_pay_snaive)
```

## Random Walk without Drift

```{r}

OB_monthly_hrs_seas_adj <- outbound_summary_monthly_hrs_ts - outbound_monthly_decomp_hrs$seasonal
OB_monthly_pay_seas_adj <- outbound_summary_monthly_pay_ts - outbound_monthly_decomp_pay$seasonal

OB_monthly_hrs_RWF <- rwf(OB_monthly_hrs_seas_adj[,1], h=24, drift=F, level=90,95)
plot(OB_monthly_hrs_RWF)

OB_monthly_pay_RWF <- rwf(OB_monthly_pay_seas_adj[,1], h=24, drift=F, level=90,95)
plot(OB_monthly_pay_RWF)
```

## Random Walk with Drift

For the outbound series, as they have roughly constant variation and could be explained using an additive model, we can use a random walk forecasting method for a short term predictions.

```{r}

OB_monthly_hrs_seas_adj <- outbound_summary_monthly_hrs_ts - outbound_monthly_decomp_hrs$seasonal
OB_monthly_pay_seas_adj <- outbound_summary_monthly_pay_ts - outbound_monthly_decomp_pay$seasonal

OB_monthly_hrs_RWF_drift <- rwf(OB_monthly_hrs_seas_adj[,1], h=24, drift=T, level=90,95)
plot(OB_monthly_hrs_RWF_drift)

OB_monthly_pay_RWF_drift <- rwf(OB_monthly_pay_seas_adj[,1], h=24, drift=T, level=90,95)
plot(OB_monthly_pay_RWF_drift)
```


## Exponential Smoothing

## Holt-Winters
#### Inbound

Based on the decompositions from above, for the inbound series, we will need use the Holt-Winters seasonal *additive* method.

```{r}
# Monthly
# Hours

inbound_monthly_hrs_HW <- hw(inbound_summary_monthly_hrs_ts, seasonal = "additive")
plot(inbound_monthly_hrs_HW)
```

```{r}
# Pay
inbound_monthly_pay_HoltWinters <- hw(inbound_summary_monthly_pay_ts, seasonal = "additive")
plot(inbound_monthly_pay_HoltWinters)
```

Based on the Holt-Winters forecast for our monthly series, both our inbound hours and pay are expected to continue to increase heavily through 2018.

```{r}
# Weekly
# Hours
inbound_weekly_hrs_HoltWinters <- HoltWinters(inbound_summary_weekly_hrs_ts)
plot(forecast(inbound_weekly_hrs_HoltWinters))
```

```{r}
# Pay
inbound_weekly_pay_HoltWinters <- HoltWinters(inbound_summary_weekly_pay_ts)
plot(forecast(inbound_weekly_pay_HoltWinters))
```

Our Holt-Winters forecasts for the weekly series appear to be lower than those for the monthly series, and they do not increase as dramatically moving into 2018. We will need to further analyze both the series and the forecasts to determine which is closer to what we should expect moving forward.

## Holt-Winters
#### Outbound

For the outbound series, we will need use the Holt-Winters seasonal *multiplicative* method.

```{r}
# Monthly
# Hours

outbound_monthly_hrs_HW <- hw(outbound_summary_monthly_hrs_ts, seasonal = "multiplicative")
plot(outbound_monthly_hrs_HW)
```

```{r}
# Pay
outbound_monthly_pay_HoltWinters <- hw(outbound_summary_monthly_pay_ts, seasonal = "multiplicative")
plot(outbound_monthly_pay_HoltWinters)
```

The `hw` function cannot handle a series with frequency greater than 24 (in a two year period), so we cannot forecast the weekly series using the multiplicative method.

<!-- Next we should test if our models are stationary, whether or not autocorrelation exists. If they are non-stationary, then we could possibly improve them using a different technique. -->

<!-- ```{r} -->

<!-- acf(inbound_monthly_hrs_HoltWinters_Forecast$residuals[13:36]) -->
<!-- Box.test(inbound_monthly_hrs_HoltWinters_Forecast$residuals[13:36]) -->
<!-- ``` -->
<!-- ```{r} -->
<!-- acf(inbound_monthly_pay_HoltWinters_Forecast$residuals[13:36]) -->
<!-- Box.test(inbound_monthly_pay_HoltWinters_Forecast$residuals[13:36]) -->
<!-- ``` -->
<!-- ```{r} -->
<!-- acf(inbound_weekly_hrs_HoltWinters_Forecast$residuals[53:156]) -->
<!-- Box.test(inbound_weekly_hrs_HoltWinters_Forecast$residuals[53:156]) -->
<!-- ``` -->
<!-- ```{r} -->
<!-- acf(inbound_weekly_pay_HoltWinters_Forecast$residuals[53:156]) -->
<!-- Box.test(inbound_weekly_pay_HoltWinters_Forecast$residuals[53:156]) -->
<!-- ``` -->

<!-- All of our Holt-Winters models for the inbound series appear to be stationary. -->

## ARIMA

We can sometimes create better forecasts by utilizing ARIMA models. Since the mean is not quite stationary, we can take the first difference we computed. 

```{r }
#Montly Hours
plot.ts(inbound_summary_monthly_hrs_ts)
inbound_summary_monthly_hrs_ts_Diff <- diff(inbound_summary_monthly_hrs_ts)
plot.ts(inbound_summary_monthly_hrs_ts_Diff)

inbound_summary_monthly_hrs_ts2 <- diff(inbound_summary_monthly_hrs_ts, differences = 2)
plot.ts(inbound_summary_monthly_hrs_ts2)

acf2(inbound_summary_monthly_hrs_ts, max.lag = 20)


inbound_summary_monthly_hrs_ts_ARIMA <- auto.arima(inbound_summary_monthly_hrs_ts)
inbound_summary_monthly_hrs_ts_forecast <- forecast(inbound_summary_monthly_hrs_ts_ARIMA)
plot(inbound_summary_monthly_hrs_ts_forecast)

```
#Monthly Pay
```{r}
plot.ts(inbound_summary_monthly_pay_ts)
inbound_summary_monthly_pay_ts_Diff <- diff(inbound_summary_monthly_pay_ts)
plot.ts(inbound_summary_monthly_pay_ts_Diff)

inbound_summary_monthly_pay_ts2 <- diff(inbound_summary_monthly_pay_ts, differences = 2)
plot.ts(inbound_summary_monthly_pay_ts2)

acf2(inbound_summary_monthly_pay_ts, max.lag = 20)

inbound_summary_monthly_pay_ts_ARIMA <- auto.arima(inbound_summary_monthly_pay_ts)
inbound_summary_monthly_pay_ts_forecast <- forecast(inbound_summary_monthly_pay_ts_ARIMA)
plot(inbound_summary_monthly_pay_ts_forecast)

```
#Weekly Hours
```{r}
plot.ts(inbound_summary_weekly_hrs_ts)
inbound_summary_weekly_hrs_ts_Diff <- diff(inbound_summary_weekly_hrs_ts)
plot.ts(inbound_summary_weekly_hrs_ts_Diff)

inbound_summary_weekly_hrs_ts2 <- diff(inbound_summary_weekly_hrs_ts, differences = 2)
plot.ts(inbound_summary_weekly_hrs_ts2)

acf2(inbound_summary_weekly_hrs_ts, max.lag = 20)

inbound_summary_weekly_hrs_ts_ARIMA <- auto.arima(inbound_summary_weekly_hrs_ts)
inbound_summary_weekly_hrs_ts_forecast <- forecast(inbound_summary_weekly_hrs_ts_ARIMA)
plot(inbound_summary_weekly_hrs_ts_forecast)
```
#Weekly Pay
```{r}
plot.ts(inbound_summary_weekly_pay_ts)
inbound_summary_weekly_pay_ts_Diff <- diff(inbound_summary_weekly_pay_ts)
plot.ts(inbound_summary_monthly_pay_ts)

inbound_summary_weekly_pay_ts2 <- diff(inbound_summary_weekly_pay_ts, differences = 2)
plot.ts(inbound_summary_weekly_pay_ts2)

acf2(inbound_summary_weekly_pay_ts, max.lag = 20)

inbound_summary_weekly_pay_ts_ARIMA <- auto.arima(inbound_summary_weekly_pay_ts)
inbound_summary_weekly_ts_forecast <- forecast(inbound_summary_weekly_pay_ts_ARIMA)
plot(inbound_summary_weekly_ts_forecast)

```

Next we can use ARIMA to forecast our outbound series.

```{r}

acf(outbound_summary_monthly_hrs_ts)
acf(outbound_summary_monthly_pay_ts)
acf(outbound_summary_weekly_hrs_ts)
acf(outbound_summary_weekly_pay_ts)

```

<!-- # ```{r} -->
<!-- # adf.test(outbound_summary_monthly_hrs_ts) -->
<!-- # adf.test(outbound_summary_monthly_pay_ts) -->
<!-- # adf.test(outbound_summary_weekly_hrs_ts) -->
<!-- # adf.test(outbound_summary_weekly_pay_ts) -->
<!-- # ``` -->


From the Dickey-Fuller test, we can confirm that the weekly series are stationary, while the monthly are not. We apply some differencing below:

```{r}

outbound_monthly_hrs_diff1 <- diff(outbound_summary_monthly_hrs_ts, differences = 1)
adf.test(outbound_monthly_hrs_diff1)

outbound_monthly_hrs_diff2 <- diff(outbound_summary_monthly_hrs_ts, differences = 2)
adf.test(outbound_monthly_hrs_diff2)

```

The monthly hours series achieves stationarity after two differences. We can see below that this is the same for the monthly pay series as well.

```{r}

outbound_monthly_pay_diff1 <- diff(outbound_summary_monthly_pay_ts, differences = 1)
adf.test(outbound_monthly_pay_diff1)

outbound_monthly_pay_diff2 <- diff(outbound_summary_monthly_pay_ts, differences = 2)
adf.test(outbound_monthly_pay_diff2)

```

We can use the `auto.arima` as it will find the appropriate ARIMA model for us to use with each series.

```{r}
# Outbound ARIMA Models
monthly_hours <- auto.arima(outbound_summary_monthly_hrs_ts)
plot(forecast(monthly_hours))

monthly_pay <- auto.arima(outbound_summary_monthly_pay_ts)
plot(forecast(monthly_pay))

weekly_hours <- auto.arima(outbound_summary_weekly_hrs_ts)
plot(forecast(weekly_hours))

weekly_pay <- auto.arima(outbound_summary_weekly_pay_ts)
plot(forecast(weekly_pay))

```
